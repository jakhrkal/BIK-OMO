TestCase subclass: #TestingSem2	instanceVariableNames: 'people customers employees galleries stock orders p1 p2 p3 g1 g2 g3 w1 w2 c1 c2 a1 o1 o2'	classVariableNames: ''	poolDictionaries: ''	category: 'hrkaljak-vanazde1-strelnice-testy'!!TestingSem2 methodsFor: 'as yet unclassified' stamp: 'JakubHrkal 1/17/2016 21:18'!testMultiplicityFreeVisit"template for testing relation multiplicities"|data query|data := (orders  collect: [:x|x phase ]) select: [:x | x isKindOf: PaidPhase ].query := [ :x | x isNil or isKindOf: FreeVisitGalleryMixin].self assert: (data allSatisfy: query)! !!TestingSem2 methodsFor: 'as yet unclassified' stamp: 'JakubHrkal 1/17/2016 21:13'!testMultiplicityGunLicence"template for testing relation multiplicities"|data query|data := customers collect: [:x|x gunLicences ].query := [ :x | (customers select: [:c|c gunLicences includes: x ]) size <= 1].self assert: (data allSatisfy: query)! !!TestingSem2 methodsFor: 'as yet unclassified' stamp: 'JakubHrkal 1/17/2016 20:51'!testMultiplicityReservation|data query|data := orders collect: [ :o | o reservations ].query := [ :x | x shootingGallery isNil or isKindOf: ShootingGallery ].self assert: (data allSatisfy: query)! !!TestingSem2 methodsFor: 'as yet unclassified' stamp: 'JakubHrkal 1/17/2016 18:21'!testD2"Najdi všechny zákazníky kteří si alespoň jednou byli zastřílet na střelnicích se vzdáleností 50 metrů."|res gal1 gal2 r1 r2 o1 o2|gal1 := (ShootingGallery new) shootDistance: 50.0. gal2 := (ShootingGallery new).r1 := (GalleryReservation new) shootingGallery: gal1.r2 := (GalleryReservation new) shootingGallery: gal2.o1 := (OrderRelator new). o1 reservations add: r1.o2 := (OrderRelator new). o2 reservations add: r2.c1 ordering orders add: o1.c2 ordering orders add: o2.res := customers select: [ :c | (( c ordering orders flatCollect: [ :o | o reservations collect: [ :r | r shootingGallery ] ] ) select: [ :gal | gal shootDistance = 50.0 ] ) size > 0 ] .self assert: res size = 1.self assert: (res includes: c1).! !!TestingSem2 methodsFor: 'as yet unclassified' stamp: 'JakubHrkal 1/17/2016 18:51'!testD1"Najdi všechny střelné zbraně prodané zákazníkovi jménem Štěpán Střelený."| cus o1 o2 res|o1 := (OrderRelator new).o2 := (OrderRelator new).c1 ordering orders add: o1; add: o2.o1 goods add: g1; add:g2; add:w1.o2 goods add: g3; add: a1.cus := self getCustByName: 'Štěpán Střelený'.res := cus ordering orders flatCollect: [ :o | o goods select: [ :w | w isKindOf: Gun ] ].self assert: res size = 3.self assert: (res includes: g1; includes: g2; includes: g3).! !!TestingSem2 methodsFor: 'as yet unclassified' stamp: 'JakubHrkal 1/17/2016 18:29'!testP3"Prodat lze jen takové zboží, které máme alespoň jednou na skladě.""pozn: zbozi prodame tak, ze objednavka prejde do faze PaidPhase."|query isAvail av1 o1 o2 o3 paid|isAvail := [ :g | g availibity goodsInStock > 0].query := [ :o | (o phase = OrderedPhase) ifFalse: [ o goods allSatisfy: isAvail]].av1 := (Availibity new) goodsInStock: 5.paid := (PaidPhase new).g1 availibity: av1.o1 := (OrderRelator new).o1 goods add: g1.o1 phase: paid.o3 := (OrderRelator new). o3 goods add: g1.orders := (Set new) add: o1; add: o3; yourself.self assert: (orders allSatisfy: query ).o2 := (OrderRelator new).o2 goods add: g2.o2 phase: (PaidPhase new).orders add: o2.orders add: o1. "delete"self deny: (orders allSatisfy: query).! !!TestingSem2 methodsFor: 'as yet unclassified' stamp: 'JakubHrkal 1/17/2016 20:32'!testD3"Najdi všechny objednávky vyřízené zaměstnancem jménem Norbert Netrefil."|res e1 e2  o1 o2 o3 o4|e1 := (EmployeesRole new) person: p2.e2 := (EmployeesRole new) person: p3.o1 := (OrderRelator new) executes: e1. o2 := (OrderRelator new) executes: e2. o3 := (OrderRelator new) executes: e1. o4 := (OrderRelator new). orders add: o1; add: o1; add: o3; add: o4.employees add: e1; add: e2.res := orders select: [:o | ( o executes ifNotNil: [ o executes person name]) = 'Norbert Netrefil'].self assert: res size = 2.self assert: (res includes: o1; includes: o3).! !!TestingSem2 methodsFor: 'as yet unclassified' stamp: 'JakubHrkal 1/17/2016 19:03'!testD4"Za kolik peněz u nás celkem nakoupil pan Kamil Kohoutek?"|res  o1 o2 o3 o4 cus |o1 := (OrderRelator new). o2 := (OrderRelator new). o3 := (OrderRelator new). "not ordered by Mr. Kohoutek"o4 := (OrderRelator new). o1 goods add: g1; add: w1.o2 goods add: g2; add: w2.o3 goods add: g3; add: a1.c2 ordering orders add: o1; add: o2; add: o4.cus := self getCustByName: 'Kamil Kohoutek'.res := cus ordering orders inject: 0 into: [:sum :each | sum + each totalPrice].self assert: res = 1150.! !!TestingSem2 methodsFor: 'as yet unclassified' stamp: 'JakubHrkal 1/16/2016 20:21'!testP1"Každému zaměstnanci i zákazníkovi musí být alespoň 18 let."|query p4 |"query := [ :x |(people select:[:p | p age < 18]) size = 0]."query := [ :p | p age >= 18].self assert: (people allSatisfy: query ).p4 := (Person new) dateOfBirth: '04/08/2015' asDate.people add: p4.self deny: (people allSatisfy: query).! !!TestingSem2 methodsFor: 'as yet unclassified' stamp: 'JakubHrkal 1/17/2016 20:51'!testMultiplicityOrderPhase|data query|data := orders.query := [ :x | x phase isKindOf:OrderedPhase or isKindOf: PaidPhase ].self assert: (data allSatisfy: query)! !!TestingSem2 methodsFor: 'as yet unclassified' stamp: 'JakubHrkal 1/17/2016 19:28'!testLazyInit|c o|c := (CustomerRole new).o := (OrderRelator new).self assert: (o goods notNil).self assert: (o reservations notNil).self assert: (c registrationDate notNil). ^true! !!TestingSem2 methodsFor: 'as yet unclassified' stamp: 'JakubHrkal 1/17/2016 20:53'!testMultiplicityOrderingPerson|data query|data := customers.data addAll: employees.query := [ :x | x ordering orders size > 0 ].self assert: (data allSatisfy: query)! !!TestingSem2 methodsFor: 'as yet unclassified' stamp: 'JakubHrkal 1/17/2016 19:34'!testSalary|e|e := (EmployeesRole new) baseSalary: 20000.self assert: e salary = 21000.! !!TestingSem2 methodsFor: 'as yet unclassified' stamp: 'JakubHrkal 1/17/2016 20:43'!setUpp1 := (Person new) name: 'Štěpán Střelený'; personID: 1; dateOfBirth: '10/02/1990' asDate . "zakaznik - podle implementace doplnit atributy"p2 := (Person new) name: 'Norbert Netrefil'; personID: 2; dateOfBirth: '10/02/1990' asDate. "zamestnanec"p3 := (Person new) name: 'Kamil Kohoutek'; personID: 3; dateOfBirth: '10/02/1990' asDate.c1 := (CustomerRole new) person: p1.c2 := (CustomerRole new) person: p3. g1 := (Gun new) SerialNumber: 1; Unlicensed: false; classification: 'B'; kind:'handgun'; price: 100.g2 := (Gun new) SerialNumber: 2; Unlicensed: false; classification: 'A'; kind:'rifle'; price: 1000.g3 := (Gun new) SerialNumber: 3; Unlicensed: false; classification: 'C'; kind:'handgun'; price: 200.w1 := (StabWeapon new) SerialNumber: 4; Unlicensed: true;  size: '12"'; price: 50.w2 := (StabWeapon new) SerialNumber: 5; Unlicensed: true;  size: '12"'.a1 := (Ammunition new) calibers: 12; count:  10; price: 10.o1 := (OrderRelator new). c1 ordering orders add: o1.o2 := (OrderRelator new). c2 ordering orders add: o2.people := (Set new) add: p1; add: p2; add: p3; yourself.customers := (Set new) add: c1; add: c2; yourself.stock := (Set new) add: g1; add: g2; add: g3; add: w1; add: w2; add: a1; yourself.orders := (Set new).employees := (Set new).! !!TestingSem2 methodsFor: 'as yet unclassified' stamp: 'JakubHrkal 1/17/2016 21:59'!testMultiplicityGunParts"template for testing relation multiplicities"|data parts query|data := stock select: [:x | x isKindOf: Gun].parts := data collect: [ :x | x magazine ].query := [ :x | (data select: [:z|z magazine = x]) = 1].(parts includes: nil) ifFalse: [self assert: (parts allSatisfy: query)].parts := data collect: [ :x | x firingPin ].query := [ :x | (data select: [:z | z firingPin = x ]) size = 1].self assert: (parts allSatisfy: query).parts := data collect: [ :x | x grip  ].query := [ :x | (data select: [:z|z grip = x ]) size = 1].self assert: (parts allSatisfy: query).parts := data collect: [ :x | x barrel ].query := [ :x | (data select: [:z|z barrel = x ]) size = 1].self assert: (parts allSatisfy: query).! !!TestingSem2 methodsFor: 'as yet unclassified' stamp: 'JakubHrkal 1/17/2016 20:51'!testMultiplicity"template for testing relation multiplicities"|data query|data := orders.query := [ :x | x ].self assert: (data allSatisfy: query)! !!TestingSem2 methodsFor: 'as yet unclassified' stamp: 'JakubHrkal 1/16/2016 20:19'!testP2"Každý registrovaný zákazník musí vlastnit zbrojní pas."|query l1 l2 c3 |query := [ :c | c hasGunLicence ].l1 := (GunLicense new).l2 := (GunLicense new).c1 gunLicences add: l1.c2 gunLicences add: l2.self assert: (customers allSatisfy: query ).c3 := (CustomerRole new).customers add: c3.self deny: (customers allSatisfy: query).! !!TestingSem2 methodsFor: 'as yet unclassified' stamp: 'JakubHrkal 1/14/2016 23:19'!testSanity^true! !!TestingSem2 methodsFor: 'as yet unclassified' stamp: 'JakubHrkal 1/17/2016 21:07'!testMultiplicityOrdering|data actors query|data := customers collect: [:x | x ordering].data addAll: (employees collect: [ :x | x ordering]).actors := customers.actors addAll: employees.query := [ :x | (actors select: [:a | a ordering = x]) size = 1 ].self assert: (data allSatisfy: query)! !!TestingSem2 methodsFor: 'as yet unclassified' stamp: 'JakubHrkal 1/17/2016 18:50'!getCustByName: aString^customers detect: [ :c | c person name = aString ].! !